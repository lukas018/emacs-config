#+title: Doom Emacs Configuration
#+author: Lukas Lundmark

#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+options: coverpage:yes
#+startup: fold

* Basic Configuration
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/bin/bash
#+end_src

** Personal Information
It's useful to have some basic personal information
#+begin_src emacs-lisp
(setq user-full-name "luklun"
      user-mail-address "lukas.lundmark@protonmail.com")
#+end_src

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

** Better Defaults

*** General settings
#+begin_src emacs-lisp
(setq-default
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "â€¦")               ; Unicode ellispis are nicer than "...", and also save /precious/ space

(display-time-mode 1)                             ; Enable time in the mode-line

(if (equal "Battery status not available"
           (battery))
    (display-battery-mode 1)                        ; On laptops it's nice to know how much power you have
  (setq password-cache-expiry nil))               ; I can trust my desktops ... can't I? (no battery = desktop)

(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

*** Windows
Previews are nice
#+begin_src emacs-lisp
(setq +ivy-buffer-preview t)
#+end_src

Window rotation is nice, and can be found under =SPC w r= and =SPC w R=.
/Layout/ rotation is also nice though. Let's stash this under =SPC w SPC=, inspired
by Tmux's use of =C-b SPC= to rotate windows.

We can also use winner-mode to restore changes in window arrangements.
Lets make use of the arrow keys for a change.

#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      "<left>"     #'winner-undo
      "<up>"       #'winner-redo)
#+end_src

*** Bookmarks and Registers
Default Emacs have a lot of useful methods of storing information and locations.

#+begin_src emacs-lisp
(map! :leader
      :desc "List bookmarks"
      "b L" 'list-bookmarks
      :leader
      :desc "Save current bookmarks to bookmark file"
      "b w" 'bookmark-save)
#+end_src

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("r" . "registers")
       :desc "Copy to register" "c" 'copy-to-register
       :desc "Framset to register" "f" 'frameset-to-register
       :desc "Insert contents of register" "i" 'insert-register
       :desc "Jump to register" "j" 'jump-to-register
       :desc "Interactively choose a register" "i" 'counsel-register
       :desc "View a register" "v" 'view-register
       :desc "Window configuration to register" "w" 'window-configuration-to-register
       :desc "Increment register" "+" 'increment-register
       :desc "Point to register" "SPC" 'point-to-register))
#+end_src
*** Navigation
Some more convenient ways to move around

This enables us to use evil snipe when in visual mode
#+begin_src emacs-lisp :tangle yes
(after! evil-snipe
  (define-key evil-snipe-parent-transient-map (kbd "C-;")
  (evilem-create 'evil-snipe-repeat
                 :bind ((evil-snipe-scope 'buffer)
                        (evil-snipe-enable-highlight)
                        (evil-snipe-enable-incremental-highlight))))

  (evil-define-key 'visual evil-snipe-local-mode-map "z" 'evil-snipe-s)
  (evil-define-key 'visual evil-snipe-local-mode-map "Z" 'evil-snipe-S))
#+end_src


** Doom configuration
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behavior.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** Structure
As you may have noticed by this point, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration. Doom
has good support for this which we access though the ~literate~ module.

While we're in the src_elisp{:config} section, we'll use Dooms nicer defaults,
along with the bindings and smartparens behaviour (the flags aren't documented,
but they exist).
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** Interface
There's a lot that can be done to enhance Emacs' capabilities.
I reckon enabling half the modules Doom provides should do it.

#+name: doom-completion
#+begin_src emacs-lisp
(company                      ; the ultimate code completion backend
 ;;+childframe                  ; ... when your children are better than you
 )
;; helm                       ; the *other* search engine for love and life
;; ido                        ; the other *other* search engine...
;; (ivy                         ; a search engine for love and life
;;  +icons                      ; ... icons are nice
;;  +prescient)                 ; ... I know what I want(ed)
(vertico +icons)
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft                       ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
doom-quit                    ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)             ; ðŸ™‚
;;fill-column                ; a `fill-column' indicator
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra                      ; quick documentation for related commands
;; indent-guides              ; highlighted indent columns, notoriously slow
;; (ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
 +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;;(tabs                      ; an tab bar for Emacs
;;  +centaur-tabs)           ; ... with prettier tabs
treemacs                     ; a project drawer, like neotree but cooler
;;unicode                    ; extended unicode support for various languages
vc-gutter                    ; vcs diff in the fringe
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
format                     ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
;;objed                      ; text object editing for the innocent
;;parinfer                   ; turn lisp into python, sort of
;; rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;;word-wrap                  ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)               ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
eshell                     ; the elisp shell that works everywhere
;;shell                      ; simple shell REPL for Emacs
;;term                       ; basic terminal emulator for Emacs
vterm                        ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax                       ; tasing you for every semicolon you forget
(:if (executable-find "aspell") spell) ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
ansible                      ; a crucible for infrastructure as code
(debugger +lsp)                   ; FIXME stepping through code, to help you add bugs
direnv                     ; be direct about your environment
docker                       ; port everything to containers
;;editorconfig               ; let someone else argue about tabs vs spaces
ein                          ; tame Jupyter notebooks with emacs
(eval +overlay)              ; run code, run (also, repls)
;;gist                       ; interacting with github gists
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
lsp                          ; Language Server Protocol
;;macos                      ; MacOS-specific commands
(magit                       ; a git porcelain for Emacs
 +forge)                     ; interface with git forges
make                         ; run make tasks from Emacs
;;pass                       ; password manager for nerds
pdf                          ; pdf enhancements
;;prodigy                    ; FIXME managing external services & code builders
rgb                          ; creating color strings
;;taskrunner                 ; taskrunner for all your projects
;;terraform                  ; infrastructure as code
;;tmux                       ; an API for interacting with tmux
upload                       ; map local to remote projects via ssh/ftp
;;biblio                       ; Support for references
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
tty                          ; improve the terminal Emacs experience
#+end_src

**** Language support
We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.

#+name: doom-lang
#+begin_src emacs-lisp
;;agda                       ; types of types of types of types...
;;cc                         ; C/C++/Obj-C madness
;;clojure                    ; java with a lisp
;;common-lisp                ; if you've seen one lisp, you've seen them all
;;coq                        ; proofs-as-programs
;;crystal                    ; ruby at the speed of c
;;csharp                     ; unity, .NET, and mono shenanigans
data                         ; config/data formats
;;(dart +flutter)            ; paint ui and not much else
;;elixir                     ; erlang done right
;;elm                        ; care for a cup of TEA?
emacs-lisp                   ; drown in parentheses
;;erlang                     ; an elegant language for a more civilized age
ess                          ; emacs speaks statistics
;;faust                      ; dsp, but you get to keep your soul
;;fsharp                     ; ML stands for Microsoft's Language
;;fstar                      ; (dependent) types and (monadic) effects and Z3
;;(go +lsp)                  ; the hipster dialect
;; (haskell +lsp)            ; a language that's lazier than I am
;;hy                         ; readability of scheme w/ speed of python
;;idris                      ;
json                         ; At least it ain't XML
;;(java +meghanada)          ; the poster child for carpal tunnel syndrome
(javascript +lsp)            ; all(hope(abandon(ye(who(enter(here))))))
;; (julia +lsp)                 ; a better, faster MATLAB
;;kotlin                     ; a better, slicker Java(Script)
(latex                       ; writing papers in Emacs has never been so fun
 +latexmk                    ; what else would you use?
 +cdlatex
 +lsp)                    ; quick maths symbols
 ;; +fold)                      ; fold the clutter away nicities
;;lean                       ; proof that mathematicians need help
;;factor                     ; for when scripts are stacked against you
;;ledger                     ; an accounting system in Emacs
lua                          ; one-based indices? one-based indices
markdown                     ; writing docs for people to ignore
;;nim                        ; python + lisp at the speed of c
;;nix                        ; I hereby declare "nix geht mehr!"
;;ocaml                      ; an objective camel
(org                         ; organize your plain life in plain text
 +pretty                     ; yessss my pretties! (nice unicode symbols)
 +dragndrop                  ; drag & drop files/images into org buffers
 ;;+hugo                     ; use Emacs for hugo blogging
 +noter                      ; enhanced PDF notetaking
 +jupyter                    ; ipython/jupyter support for babel
 +pandoc                     ; export-with-pandoc support
 +gnuplot                    ; who doesn't like pretty pictures
 +pomodoro                 ; be fruitful with the tomato technique
 +present                    ; using org-mode for presentations
 +roam2
 )                      ; wander around notes
;;perl                       ; write code no one else can comprehend
;;php                        ; perl's insecure younger brother
;;plantuml                   ; diagrams for confusing people more
;;purescript                 ; javascript, but functional
(python
 +lsp
 +pyright
 ;; +poetry
 +cython
 +pyenv); beautiful is better than ugly
;;qt                         ; the 'cutest' gui framework ever
;;racket                     ; a DSL for DSLs
;;rest                       ; Emacs as a REST client
;;rst                        ; ReST in peace
;;(ruby +rails)              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)                  ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                      ; java, but good
scheme                       ; a fully conniving family of lisps
sh                           ; she sells {ba,z,fi}sh shells on the C xor
;;sml                        ; no, the /other/ ML
;;solidity                   ; do you need a blockchain? No.
;;swift                      ; who asked for emoji variables?
;;terra                      ; Earth and Moon in alignment for performance.
(web +lsp)                          ; the tubes
yaml                         ; JSON, but readable
#+end_src

**** Everything in EmacsIt's just too convenient being able to have everything in Emacs.
I couldn't resist the Email and Feed modules.

#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +org +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar                   ; A dated approach to timetabling
;;emms                       ; Multimedia in Emacs is music to my ears
everywhere                   ; *leave* Emacs!? You must be joking.
irc                          ; how neckbeards socialize
(rss +org)                   ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

*** Visual Settings
**** Font Face
'Fira Code' is nice, and 'Overpass' makes for a nice sans companion. We just need to
fiddle with the font sizes a tad so that they visually match. Just for fun I'm
trying out JetBrains Mono though. So far I have mixed feelings on it, some
aspects are nice, but on others I prefer Fira.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Fira Code" :size 12)
      doom-big-font (font-spec :family "Fira Code" :size 22)
      doom-unicode-font (font-spec :family "JuliaMono" :size 12)
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light :size 12)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 12))
#+end_src

#+attr_html: :class invertible :alt Screenshot of the fonts within Emacs.
[[https://tecosaur.com/lfs/emacs-config/screenshots/font-face.png]]

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

Because we care about how things look let's add a check to make sure we're told
if the system doesn't have any of those fonts.

#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("JetBrainsMono.*" "Overpass" "JuliaMono" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts()>>
#+end_src

This way whenever fonts are missing, after Doom's UI has initialised, a warning
listing the missing fonts should appear for at least half a second.

**** Theme and modeline
~doom-one~ is nice and all, but I find the ~vibrant~ variant nicer.

#+begin_src emacs-lisp
(setq doom-theme 'doom-moonlight)
(delq! t custom-theme-load-path)
#+end_src

However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.
#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src
While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

**** Miscellaneous
Since I navigate vertically using Avy or Swiper I rarely look at line numbers and find them to clutter the screen for the most part.
#+begin_src emacs-lisp
(setq display-line-numbers-type nil)
#+end_src

I also like to move between windows with Avy goto-char, so lets enable searching in all windows
#+begin_src emacs-lisp :tangle yes
(setq avy-all-windows t)
#+end_src

#+begin_src emacs-lisp
(setq evil-snipe-override-evil-repeat-keys nil)
#+end_src

I'd like some slightly nicer default buffer names
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "â–º Doom"
      +doom-dashboard-name "â–º Doom")
#+end_src

Since long lines are emacs' Achile's heel, it's nice to be able to toggle
line-truncation when needed.
#+begin_src emacs-lisp
(map! :leader
      :desc "Toggle truncate lines"
      "t t" 'toggle-truncate-lines)
#+end_src

Emacs is perfect for reading pdfs.
It's always a good idea to enable dark-mode as default (toggle with "z m") to
prevent blidning yourself.
#+begin_src emacs-lisp
(after! pdf-view
  (add-hook 'pdf-tools-enabled-hook 'pdf-view-midnight-minor-mode))
#+end_src

We also want links to pdf-files in org-mode to open in emacs by default.
#+begin_src emacs-lisp
(after! org
  (add-to-list 'org-file-apps '("\\.pdf\\'" . emacs)))
#+end_src

*** Some helper macros
There are a few handy macros added by doom, namely
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
  you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys

*** Allow babel execution in CLI actions

In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments none
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

** Other things
*** Splash screen
Emacs can render an image as the splash screen, and [[https://github.com/MarioRicalde][@MarioRicalde]] came up with a
cracker! He's also provided me with a nice Emacs-style /E/. I was using the
blackhole image, but as I've stripped down the splash screen I've switched to
just using the /E/.

#+attr_latex: :width 0.2\linewidth
#+attr_html: :style width:20% :alt Fancy Emacs "E"
[[file:misc/splash-images/emacs-e.svg]]

Now we just make it theme-appropriate, and resize with the frame.

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

Now the only thing missing is a an extra interesting line, whether that be some
corporate BS, an developer excuse, or a fun (useless) fact.

The following is rather long, but it essentially
+ fetches a phrase from an API
+ inserts it into the dashboard (asynchronously)
+ moves ~point~ to the phrase
+ re-uses the last phrase for requests within a few seconds of it being fetched

#+begin_src emacs-lisp
(defvar phrase-api-url
  (nth (random 3)
       '(("https://corporatebs-generator.sameerkumar.website/" :phrase)
         ("https://useless-facts.sameerkumar.website/api" :data)
         ("https://dev-excuses-api.herokuapp.com/" :text))))

(defmacro phrase-generate-callback (token &optional format-fn ignore-read-only callback buffer-name)
  `(lambda (status)
     (unless (plist-get status :error)
       (goto-char url-http-end-of-headers)
       (let ((phrase (plist-get (json-parse-buffer :object-type 'plist) (cadr phrase-api-url)))
             (inhibit-read-only ,(when (eval ignore-read-only) t)))
         (setq phrase-last (cons phrase (float-time)))
         (with-current-buffer ,(or (eval buffer-name) (buffer-name (current-buffer)))
           (save-excursion
             (goto-char (point-min))
             (when (search-forward ,token nil t)
               (with-silent-modifications
                 (replace-match "")
                 (insert ,(if format-fn format-fn 'phrase)))))
           ,callback)))))

(defvar phrase-last nil)
(defvar phrase-timeout 5)

(defmacro phrase-insert-async (&optional format-fn token ignore-read-only callback buffer-name)
  `(let ((inhibit-message t))
     (if (and phrase-last
              (> phrase-timeout (- (float-time) (cdr phrase-last))))
         (let ((phrase (car phrase-last)))
           ,(if format-fn format-fn 'phrase))
       (url-retrieve (car phrase-api-url)
                     (phrase-generate-callback ,(or token "\ufeff") ,format-fn ,ignore-read-only ,callback ,buffer-name))
       ;; For reference, \ufeff = Zero-width no-break space / BOM
       ,(or token "\ufeff"))))

(defun doom-dashboard-phrase ()
  (phrase-insert-async
   (progn
     (setq-local phrase-position (point))
     (mapconcat
      (lambda (line)
        (+doom-dashboard--center
         +doom-dashboard--width
         (with-temp-buffer
           (insert-text-button
            line
            'action
            (lambda (_)
              (setq phrase-last nil)
              (+doom-dashboard-reload t))
            'face 'doom-dashboard-menu-title
            'mouse-face 'doom-dashboard-menu-title
            'help-echo "Random phrase"
            'follow-link t)
           (buffer-string))))
      (split-string
       (with-temp-buffer
         (insert phrase)
         (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
         (fill-region (point-min) (point-max))
         (buffer-string))
       "\n")
      "\n"))
   nil t
   (progn
     (goto-char phrase-position)
     (forward-whitespace 1))
   +doom-dashboard-name))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

Lastly, the doom dashboard "useful commands" are no longer useful to me.
So, we'll disable them and then for a particularly /clean/ look disable
the modeline and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

At the end, we have a minimal but rather nice splash screen.

#+attr_html: :class invertible :alt The splash screen, just loaded.
[[https://tecosaur.com/lfs/emacs-config/screenshots/splash-screen.png]]

I haven't forgotten about the ASCII banner though! Once again we're going for
something simple.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

* Package loading
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

** General packages
*** Window management
#+begin_src emacs-lisp
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src
*** Dired
Default dired (with pretty icons of course) is fantastic, but it can be even better
with some good image preview.

#+begin_src emacs-lisp
(package! peep-dired)
#+end_src

#+begin_src emacs-lisp  :tangle yes
(use-package! peep-dired
  :after dired
  :config
  (map! :map dired-mode-map
        :after dired
        :localleader
        :desc "Peep dired (image preview)" "p" #'peep-dired)
  (evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file
    (kbd "k") 'peep-dired-prev-file)
  (add-hook 'peep-dired-hook 'evil-normalize-keymaps))
#+end_src

*** Terminal
vterm is awesome. So awesome in fact that I use it as my default terminal emulator.
Lets extend the functionality a bit so we can easily rotate between active vterm buffers
#+begin_src emacs-lisp :tangle packages.el
(package! vterm-toggle
  :pin "a0429842e6197a6ec83c0de30701127a4edb9e92"
  :recipe (:host github :repo "jixiuf/vterm-toggle"))
#+end_src

*** Procrastination
It is nice to be able use a modern messaging app once in a while.
#+begin_src emacs-lisp
(package! telega :pin "03dd159df057d0958e2473fea9ccee0dcf805900")
#+end_src

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

*** Features
**** Large files
The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.
#+begin_src emacs-lisp
(package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
  :pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c")
#+end_src
To make VLF available without delaying startup, we'll just load it in quiet moments.
#+begin_src emacs-lisp :tangle yes
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

**** Spelling
#+begin_src emacs-lisp
(package! spell-fu)

#+end_src

**** Grammar
#+begin_src emacs-lisp
(package! lsp-grammarly :recipe (:host github :repo "emacs-grammarly/lsp-grammarly"))
#+end_src

**** Tree-Sitter
#+begin_src emacs-lisp
(package! tree-sitter)
(package! tree-sitter-langs)
(package! evil-textobj-tree-sitter :recipe (
                      :host github
                      :repo "meain/evil-textobj-tree-sitter"
                      :files (:defaults "queries")))
#+end_src

Enable tree-sitter for nicer looking syntax highlighting
#+begin_src emacs-lisp :tangle yes
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src

While we are at it, let's add some of the tree-sitter word objects for evil.
If a language has tree-sitter support, we can now more easily select certain text objects
#+begin_src emacs-lisp :tangle yes
(use-package! evil-textobj-tree-sitter
  :config
  (define-key evil-outer-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.outer"))
  (define-key evil-inner-text-objects-map "f" (evil-textobj-tree-sitter-get-textobj "function.inner"))
  (define-key evil-outer-text-objects-map "C" (evil-textobj-tree-sitter-get-textobj "class.outer"))
  (define-key evil-inner-text-objects-map "C" (evil-textobj-tree-sitter-get-textobj "class.inner"))
  (define-key evil-outer-text-objects-map "P" (evil-textobj-tree-sitter-get-textobj "parameter.outer"))
  (define-key evil-inner-text-objects-map "P" (evil-textobj-tree-sitter-get-textobj "parameter.inner"))
  (define-key evil-outer-text-objects-map "l" (evil-textobj-tree-sitter-get-textobj "loop.outer"))
  (define-key evil-inner-text-objects-map "l" (evil-textobj-tree-sitter-get-textobj "loop.inner"))
  (define-key evil-outer-text-objects-map "b" (evil-textobj-tree-sitter-get-textobj "block.outer"))
  (define-key evil-inner-text-objects-map "b" (evil-textobj-tree-sitter-get-textobj "block.inner"))
  (define-key evil-outer-text-objects-map "I" (evil-textobj-tree-sitter-get-textobj "conditional.outer"))
  (define-key evil-inner-text-objects-map "I" (evil-textobj-tree-sitter-get-textobj "conditional.inner"))
  (define-key evil-outer-text-objects-map "s" (evil-textobj-tree-sitter-get-textobj "statement.outer")))
#+end_src
**** Smooth scrolling

#+begin_src emacs-lisp
(package! gitconfig-mode
	  :recipe (:host github :repo "magit/git-modes"
			 :files ("gitconfig-mode.el")))
(package! gitignore-mode
	  :recipe (:host github :repo "magit/git-modes"
			 :files ("gitignore-mode.el")))
#+end_src

#+begin_src emacs-lisp
(package! sublimity)
#+end_src

#+begin_src emacs-lisp :tangle yes
;; (use-package! sublimity
;;   :config
;;   (require 'sublimity)
;;   (require 'sublimity-scroll)
;;   (sublimity-mode 1))
#+end_src

**** Git Blame
#+begin_src emacs-lisp
(package! blamer :recipe (:host github :repo "artawower/blamer.el"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package blamer
  :defer 20
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                    :background nil
                    :height 140
                    :italic t))))
#+end_src

** Language packages
#+begin_src emacs-lisp
(unpin! lsp-mode)
#+end_src

*** LaTeX
For mathematical convenience, WIP
#+begin_src emacs-lisp
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "e2b3edafd7aafa8c47833a70984d7404c607626c")
(package! laas :recipe (:local-repo "lisp/LaTeX-auto-activating-snippets"))
#+end_src
And some basic config
#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)

(use-package! laas
  :hook (LaTeX-mode . laas-mode)
  :config
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src

I think the latest AucTeX may be a bit dodgy, so
#+begin_src emacs-lisp
(package! auctex :pin "384c4b989192087144512a528bcc1949c2ab3e5b")
#+end_src

*** Org Mode
Use ~HEAD~ for development.
#+begin_src emacs-lisp
;; (unpin! org-mode)
#+end_src

**** Improve agenda/capture
The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp
(package! org-super-agenda :pin "f5e80e4d0da6b2eeda9ba21e021838fa6a495376")
#+end_src

Similarly ~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "8ac08633ae413a6605b6506d2739eece7475272e")
#+end_src
**** Visuals
Org tables aren't the prettiest thing to look at. This package is supposed to
redraw them in the buffer with box-drawing characters. Sounds like an
improvement to me! Just need to get it working...
#+begin_src emacs-lisp
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "474ad84a8fe5377d67ab7e491e8e68dac6e37a11")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

For automatically toggling LaTeX fragment previews there's this nice package
#+begin_src emacs-lisp
(package! org-fragtog :pin "0151cabc7aa9f244f82e682b87713b344d780c23")
#+end_src

Then for pretty markers
#+begin_src emacs-lisp
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "0b3b029d5851c77ee792727b280f062eaf2c22c7")
#+end_src

~org-superstar-mode~ is great. While we're at it we may as well make tags prettier as well :)
#+begin_src emacs-lisp
(package! org-pretty-tags :pin "5c7521651b35ae9a7d3add4a66ae8cc176ae1c76")
#+end_src

There's this nice package that can provide nice syntax highlighting with LaTeX
exports.
#+begin_src emacs-lisp
(package! engrave-faces :recipe (:local-repo "lisp/engrave-faces"))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src
**** Extra functionality
Because of the /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][lovely variety in markdown implementations]]/ there isn't actually
such a thing a standard table spec ... or standard anything really. Because
~org-md~ is a goody-two-shoes, it just uses HTML for all these non-standardised
elements (a lot of them). So ~ox-gfm~ is handy for exporting markdown with all the
features that GitHub has.
#+begin_src emacs-lisp
(package! ox-gfm :pin "99f93011b069e02b37c9660b8fcb45dab086a07f")
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! ox-gfm
  :after org)
#+end_src

Now and then citations need to happen
#+begin_src emacs-lisp
(package! org-ref :pin "3ca9beb744621f007d932deb8a4197467012c23a")
(package! org-roam-bibtex
  :recipe (:host github :repo "org-roam/org-roam-bibtex"))
(unpin! org-roam)
(unpin! bibtex-completion helm-bibtex ivy-bibtex)
#+end_src

Came across this and ... it's cool
#+begin_src emacs-lisp
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "13314338d70d2c19511efccc491bed3ca0758170")
#+end_src

I *need* this in my life. It take a URL to a recipe from a common site, and
inserts an org-ified version at point. Isn't that just great.
#+begin_src emacs-lisp
(package! org-chef :pin "5b461ed7d458cdcbff0af5013fbdbe88cbfb13a4")
#+end_src

Sometimes I'm given non-org files, that's very sad. Luckily Pandoc offers a way
to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp
(package! org-pandoc-import :recipe
  (:local-repo "lisp/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src


#+begin_src emacs-lisp
(after! org-roam
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  (map! :leader
      :desc "Insert immediately" "n r I" #'org-roam-node-insert-immediate)

  )
#+end_src

Org-roam is nice by itself, but there are so /extra/ nice packages which integrate
with it.
#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")) :pin "c745d07018a46b1a20b9f571d999ecf7a092c2e1")
(package! websocket :pin "fda4455333309545c0787a79d73c19ddbeb57980") ; dependency of `org-roam-ui'
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands org-roam-ui-open
  :hook (org-roam . org-roam-ui-mode)
  :config
  (require 'org-roam) ; in case autoloaded
  (defun org-roam-ui-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (unless org-roam-ui-mode (org-roam-ui-mode 1))
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-ui-port))))
#+end_src

*** Systemd
For editing systemd unit files
#+begin_src emacs-lisp
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

*** Python
While the Doom defaults offers a really good python programming environment it
lacks some support for docstring writing.

Lets start by getting some syntax highlighting in our docstring

#+begin_src emacs-lisp
(package! python-docstring-mode
  :recipe (:host github
           :repo "glyph/python-docstring-mode"
           :branch "master"
           :files ("*.el" "*.py"))
  :pin "ec253711f2bdcb3848046bb68f6405a7bf9eb0fb")
#+end_src

We also need a reliable way to auto-generate and format our docstrings
#+begin_src emacs-lisp
(package! sphinx-doc
  :pin "1eda612a44ef027e5229895daa77db99a21b8801")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! sphinx-doc
  :hook ((python-mode . sphinx-doc-mode)
         (python-mode . python-docstring-mode))
  :config
  (map! :after python
        :localleader
        :map python-mode-map
        (:prefix ("d" . "docstring")
         :desc "format docstring" "d" #'sphinx-doc)))
#+end_src

# A faster lsp-server written in ... typescript *sight*
# #+begin_src emacs-lisp
# (package! lsp-pyright)
# #+end_src

** Themes
The default doom themes are pretty nice, but we need more =bling= baby
#+begin_src emacs-lisp
(package! nano-theme
  :recipe (:host github :repo "rougier/nano-theme"))
#+end_src

* Package Configuration
** Company
It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0
        company-minimum-prefix-length 1)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src
Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src
*** Plain Text
~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src
We then configure the dictionary we're using in [[*Ispell][Ispell]].
*** ESS
~company-dabbrev-code~ is nice. Let's have it.
#+begin_src emacs-lisp
(set-company-backend! 'ess-r-mode '(company-R-args company-R-objects company-dabbrev-code :separate))
#+end_src

** VTERM
Let's start with allowing us to rotate between active vterm sessions

#+begin_src emacs-lisp
(use-package! vterm-toggle
  :after vterm
  :config
  (require 'vterm-toggle)
  (map! :leader
        (:prefix ("v" . "vterm")
         :desc "open vterm" "o" #'vterm-toggle-cd-show
         :desc "hide vterm" "h" #'vterm-toggle-hide
         :desc "next vterm" "n" #'vterm-toggle-backward
         :desc "prev vterm" "p" #'vterm-toggle-forward
         :desc "copy mode" "c" #'vterm-copy-mode)))
#+end_src

#+begin_src emacs-lisp
(after! vterm
  (add-to-list 'vterm-eval-cmds '("update-pwd" (lambda (path) (setq default-directory path)))))
#+end_src

This makes it easier for us to move up in our auto-completion history
TODO: Find some way to enable evil-escape mode in vterm
#+begin_src emacs-lisp
(use-package! vterm
  :bind
  (:map vterm-mode-map
   ("C-k" . vterm-send-up)
   ("M-k" . vterm-send-up)
   ("M-l" . vterm-send-right)
   ("C-j" . vterm-send-down)
   ("M-j" . vterm-send-down)
   ("M-h" . vterm-send-left)
   ("M-k" . vterm-send-up)))
#+end_src

If we want to use vterm via TRAMP on an ssh connection via a port we need to add
some modifications to dooms +vterm functionality.

#+begin_src emacs-lisp
(after! vterm
  (defadvice! luklun/+vterm--change-directory-if-remote ()
    :override #'+vterm--change-directory-if-remote
    (when (and (featurep 'tramp)
               (tramp-tramp-file-p default-directory))
      (message "default-directory is %s" default-directory)
      (with-parsed-tramp-file-name default-directory path
        (let ((method (cadr (assoc `tramp-login-program
                                   (assoc path-method tramp-methods)))))
          (vterm-send-string
           (concat method " "
                   (when path-user (concat path-user "@"))
                   path-host
                   (when path-port (concat " -p " path-port))
                   (when path-localname (format " -t \'cd %s;  exec zsh -l\'" path-localname))))
          (vterm-send-return))))))
#+end_src

Increase the default scrollback in vterm
#+begin_src emacs-lisp
(setq vterm-max-scrollback 100000)
#+end_src

Shamelessly copied from ~u/phalp~ on r/emacs.
Provides a way to launch a new *vterm* instance with a specific command.
#+begin_src emacs-lisp
(defun luklun/run-in-vterm-kill (process event)
"A process sentinel. Kills PROCESS's buffer if it is live."
(let ((b (process-buffer process)))
(and (buffer-live-p b)
        (kill-buffer b))))

(defun luklun/run-in-vterm (command)
"Execute string COMMAND in a new vterm.

Interactively, prompt for COMMAND with the current buffer's file
name supplied. When called from Dired, supply the name of the
file at point.

Like `async-shell-command`, but run in a vterm for full terminal features.

The new vterm buffer is named in the form `*foo bar.baz*`, the
command and its arguments in earmuffs.

When the command terminates, the shell remains open, but when the
shell exits, the buffer is killed."
(interactive
(list
(let* ((f (cond (buffer-file-name)
                ((eq major-mode 'dired-mode)
                    (dired-get-filename nil t))))
        (filename (concat " " (shell-quote-argument (and f (file-relative-name f))))))
    (read-shell-command "Terminal command: "
                        (cons filename 0)
                        (cons 'shell-command-history 1)
                        (list filename)))))
(with-current-buffer (vterm (concat "*" command "*"))
(set-process-sentinel vterm--process #'luklun/run-in-vterm-kill)
(vterm-send-string command)
(delete-other-windows)
(vterm-send-return)))
#+end_src

** Doom modeline
Very nice and pretty, however I think the PDF modeline could do with tweaking.
I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this, however the response was basically "put your
preferences in your personal config, the current default is sensible" --- so
here we are.

First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

** Emacs Everywhere
In the case we are running as a damon, we should load the emacs-everywhere functionality
#+begin_src emacs-lisp
(when (daemonp)
  (require 'spell-fu)
  (setq emacs-everywhere-major-mode-function #'org-mode
        emacs-everywhere-frame-name-format "Edit âˆ· %s â€” %s")
  (require 'emacs-everywhere))
#+end_src

** Ivy
While in an ivy mini-buffer =C-o= shows a list of all possible actions one may take.
By default this is src_elisp{#'ivy-read-action-by-key} however a better
interface to this is using Hydra.
#+begin_src emacs-lisp
(setq ivy-read-action-function #'ivy-hydra-read-action)
#+end_src

I currently have ~40k functions. This seems like sufficient motivation to
increase the maximum number of items ivy will sort to 40k + a bit, this way
=SPC h f= et al. will continue to function as expected.
#+begin_src emacs-lisp
(setq ivy-sort-max-size 50000)
#+end_src

** Smart Parentheses
#+begin_src emacs-lisp
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src

** Theme magic
Let's automatically update terminals on theme change (as long as ~pywal~ is available).

Unfortunately, as the theme is set on startup this causes the hook to be run
immediately. It would be nicer to /not/ have this add to our precious startup
time (around 0.4s last time I checked).
We can achieve this by deferring it with a short idle timer that should add the
hook /just after/ initialisation.

#+begin_src emacs-lisp :tangle (if (executable-find "wal") "yes" "no")
(run-with-idle-timer 0.1 nil (lambda () (add-hook 'doom-load-theme-hook 'theme-magic-from-emacs)))
#+end_src

** Tramp
Let's try to make tramp handle prompts better
#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|
\\)[^]#$%>\n]*#?[]#$%>î‚°] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + î‚°
#+end_src
*** Troubleshooting
In case the remote shell is misbehaving, here are some things to try
**** Zsh
There are some escape code you don't want, let's make it behave more considerately.
#+begin_src shell :eval no :tangle no
if [[ "$TERM" == "dumb" ]]; then
    unset zle_bracketed_paste
    unset zle
    PS1='$ '
    return
fi
#+end_src
Also, add zsh as the default shell for emacs
#+begin_src emacs-lisp
(setq-default shell-file-name "/bin/zsh")
#+end_src

** Which-key
Let's make this popup a bit faster
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src
I also think that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "â—‚\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "â—ƒ\\1"))
   ))
#+end_src

#+attr_html: :class invertible :alt Whichkey triggered on an evil motion
[[https://tecosaur.com/lfs/emacs-config/screenshots/whichkey-evil.png]]

** YASnippet
Snippets within snippets...yes please!
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src
Having yas bound to tab is a bit annoying when using lsp-compay.
For more control it is probably better to bound it to an explicit command.

#+begin_src emacs-lisp :tangle yes
(after! yasnippet
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "C-,") yas-maybe-expand))
#+end_src

* Applications
** Newsfeed
RSS feeds are still a thing. Why not make use of them with =elfeed=.
I really like what [[https://github.com/fuxialexander/doom-emacs-private-xfu/tree/master/modules/app/rss][fuxialexander]] has going on, but I don't think I need a custom
module. Let's just try to patch on the main things I like the look of.

*** Keybindings
#+begin_src emacs-lisp
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :n "q" #'+rss/quit
      :n "e" #'elfeed-update
      :n "r" #'elfeed-search-untag-all-unread
      :n "u" #'elfeed-search-tag-all-unread
      :n "s" #'elfeed-search-live-filter
      :n "RET" #'elfeed-search-show-entry
      :n "p" #'elfeed-show-pdf
      :n "+" #'elfeed-search-tag-all
      :n "-" #'elfeed-search-untag-all
      :n "S" #'elfeed-search-set-filter
      :n "b" #'elfeed-search-browse-url
      :n "y" #'elfeed-search-yank)
(map! :map elfeed-show-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :nm "q" #'+rss/delete-pane
      :nm "o" #'ace-link-elfeed
      :nm "RET" #'org-ref-elfeed-add
      :nm "n" #'elfeed-show-next
      :nm "N" #'elfeed-show-prev
      :nm "p" #'elfeed-show-pdf
      :nm "+" #'elfeed-show-tag
      :nm "-" #'elfeed-show-untag
      :nm "s" #'elfeed-show-new-live-search
      :nm "y" #'elfeed-show-yank)
#+end_src

Let's add some RSS sources to our feed for even more effective procrastination
#+begin_src emacs-lisp
 '(elfeed-feeds
   (quote
    (("https://www.reddit.com/r/linux.rss" reddit linux)
     ("https://www.gamingonlinux.com/article_rss.php" gaming linux)
     ("https://hackaday.com/blog/feed/" hackaday linux)
     ("https://opensource.com/feed" opensource linux)
     ("https://linux.softpedia.com/backend.xml" softpedia linux)
     ("https://itsfoss.com/feed/" itsfoss linux)
     ("https://www.zdnet.com/topic/linux/rss.xml" zdnet linux)
     ("https://www.phoronix.com/rss.php" phoronix linux)
     ("http://feeds.feedburner.com/d0od" omgubuntu linux)
     ("https://www.computerworld.com/index.rss" computerworld linux)
     ("https://www.networkworld.com/category/linux/index.rss" networkworld linux)
     ("https://www.techrepublic.com/rssfeeds/topic/open-source/" techrepublic linux)
     ("https://betanews.com/feed" betanews linux)
     ("http://lxer.com/module/newswire/headlines.rss" lxer linux)
     ("https://distrowatch.com/news/dwd.xml" distrowatch linux))))
#+end_src


*** Usability enhancements
#+begin_src emacs-lisp
(after! elfeed-search
  (set-evil-initial-state! 'elfeed-search-mode 'normal))
(after! elfeed-show-mode
  (set-evil-initial-state! 'elfeed-show-mode   'normal))

(after! evil-snipe
  (push 'elfeed-show-mode   evil-snipe-disabled-modes)
  (push 'elfeed-search-mode evil-snipe-disabled-modes))
#+end_src

*** Visual enhancements
#+begin_src emacs-lisp
(after! elfeed

  ;; Set the feed file
  (setq rmh-elfeed-org-files '("/home/luklun/.org/elfeed.org"))

  (elfeed-org)
  (use-package! elfeed-link)

  (setq elfeed-search-filter "@1-week-ago +unread"
        elfeed-search-print-entry-function '+rss/elfeed-search-print-entry
        elfeed-search-title-min-width 80
        elfeed-show-entry-switch #'pop-to-buffer
        elfeed-show-entry-delete #'+rss/delete-pane
        elfeed-show-refresh-function #'+rss/elfeed-show-refresh--better-style
        shr-max-image-proportion 0.6)

  (add-hook! 'elfeed-show-mode-hook (hide-mode-line-mode 1))
  (add-hook! 'elfeed-search-update-hook #'hide-mode-line-mode)

  (defface elfeed-show-title-face '((t (:weight ultrabold :slant italic :height 1.5)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (defface elfeed-show-author-face `((t (:weight light)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (set-face-attribute 'elfeed-search-title-face nil
                      :foreground 'nil
                      :weight 'light)

  (defadvice! +rss-elfeed-wrap-h-nicer ()
    "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
    :override #'+rss-elfeed-wrap-h
    (let ((inhibit-read-only t)
          (inhibit-modification-hooks t))
      (setq-local truncate-lines nil)
      (setq-local shr-width 120)
      (setq-local line-spacing 0.2)
      (setq-local visual-fill-column-center-text t)
      (visual-fill-column-mode)
      ;; (setq-local shr-current-font '(:family "Merriweather" :height 1.2))
      (set-buffer-modified-p nil)))

  (defun +rss/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer."
    (let* ((elfeed-goodies/tag-column-width 40)
           (elfeed-goodies/feed-source-column-width 30)
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat (mapconcat 'identity tags ",")))
           (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                           elfeed-goodies/tag-column-width 4))

           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left)))

      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
      (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
      (insert (propertize title 'face title-faces 'kbd-help title))
      (setq-local line-spacing 0.2)))

  (defun +rss/elfeed-show-refresh--better-style ()
    "Update the buffer to match the selected entry, using a mail-style."
    (interactive)
    (let* ((inhibit-read-only t)
           (title (elfeed-entry-title elfeed-show-entry))
           (date (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (author (elfeed-meta elfeed-show-entry :author))
           (link (elfeed-entry-link elfeed-show-entry))
           (tags (elfeed-entry-tags elfeed-show-entry))
           (tagsstr (mapconcat #'symbol-name tags ", "))
           (nicedate (format-time-string "%a, %e %b %Y %T %Z" date))
           (content (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (type (elfeed-entry-content-type elfeed-show-entry))
           (feed (elfeed-entry-feed elfeed-show-entry))
           (feed-title (elfeed-feed-title feed))
           (base (and feed (elfeed-compute-base (elfeed-feed-url feed)))))
      (erase-buffer)
      (insert "\n")
      (insert (format "%s\n\n" (propertize title 'face 'elfeed-show-title-face)))
      (insert (format "%s\t" (propertize feed-title 'face 'elfeed-search-feed-face)))
      (when (and author elfeed-show-entry-author)
        (insert (format "%s\n" (propertize author 'face 'elfeed-show-author-face))))
      (insert (format "%s\n\n" (propertize nicedate 'face 'elfeed-log-date-face)))
      (when tags
        (insert (format "%s\n"
                        (propertize tagsstr 'face 'elfeed-search-tag-face))))
      ;; (insert (propertize "Link: " 'face 'message-header-name))
      ;; (elfeed-insert-link link link)
      ;; (insert "\n")
      (cl-loop for enclosure in (elfeed-entry-enclosures elfeed-show-entry)
               do (insert (propertize "Enclosure: " 'face 'message-header-name))
               do (elfeed-insert-link (car enclosure))
               do (insert "\n"))
      (insert "\n")
      (if content
          (if (eq type 'html)
              (elfeed-insert-html content base)
            (insert content))
        (insert (propertize "(empty)\n" 'face 'italic)))
      (goto-char (point-min))))

  )
#+end_src
*** Functionality enhancements
#+begin_src emacs-lisp
(after! elfeed-show
  (require 'url)

  (defvar elfeed-pdf-dir
    (expand-file-name "pdfs/"
                      (file-name-directory (directory-file-name elfeed-enclosure-default-dir))))

  (defvar elfeed-link-pdfs
    '(("https://www.jstatsoft.org/index.php/jss/article/view/v0\\([^/]+\\)" . "https://www.jstatsoft.org/index.php/jss/article/view/v0\\1/v\\1.pdf")
      ("http://arxiv.org/abs/\\([^/]+\\)" . "https://arxiv.org/pdf/\\1.pdf"))
    "List of alists of the form (REGEX-FOR-LINK . FORM-FOR-PDF)")

  (defun elfeed-show-pdf (entry)
    (interactive
     (list (or elfeed-show-entry (elfeed-search-selected :ignore-region))))
    (let ((link (elfeed-entry-link entry))
          (feed-name (plist-get (elfeed-feed-meta (elfeed-entry-feed entry)) :title))
          (title (elfeed-entry-title entry))
          (file-view-function
           (lambda (f)
             (when elfeed-show-entry
               (elfeed-kill-buffer))
             (pop-to-buffer (find-file-noselect f))))
          pdf)

      (let ((file (expand-file-name
                   (concat (subst-char-in-string ?/ ?, title) ".pdf")
                   (expand-file-name (subst-char-in-string ?/ ?, feed-name)
                                     elfeed-pdf-dir))))
        (if (file-exists-p file)
            (funcall file-view-function file)
          (dolist (link-pdf elfeed-link-pdfs)
            (when (and (string-match-p (car link-pdf) link)
                       (not pdf))
              (setq pdf (replace-regexp-in-string (car link-pdf) (cdr link-pdf) link))))
          (if (not pdf)
              (message "No associated PDF for entry")
            (message "Fetching %s" pdf)
            (unless (file-exists-p (file-name-directory file))
              (make-directory (file-name-directory file) t))
            (url-copy-file pdf file)
            (funcall file-view-function file))))))

  )
#+end_src

** Dictionary
We start off by loading =lexic=, then we'll integrate it into pre-existing
definition functionality (like ~+lookup/dictionary-definition~).
#+begin_src emacs-lisp
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

Now let's use this instead of wordnet.
#+begin_src emacs-lisp
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override '+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
#+end_src

** General
*** File Templates
For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.
#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src
* Language Configuration
** Plaintext
It's nice to see ANSI colour codes displayed
#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max)))))
#+end_src

** Org Mode
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:
:intro:

Load this mess after we initialize org-mode, as to speed up the start up
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src

#+begin_src emacs-lisp
(setq org-directory "~/org"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

#+end_src

Save the link as a comment in tangled files.
Makes it easier to know where something went wrong.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

#+begin_src emacs-lisp
  (use-package! ox-latex
    :config
    ;; code here will run after the package is loaded
    (setq org-latex-pdf-process
          '("pdflatex -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -interaction nonstopmode -output-directory %o %f"
            "pdflatex -interaction nonstopmode -output-directory %o %f"))
    (setq org-latex-with-hyperref nil)
    ;; deleted unwanted file extensions after latexMK
    (setq org-latex-logfiles-extensions
          (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf" "acn" "acr" "alg" "glg" "gls" "ist")))

    (unless (boundp 'org-latex-classes)
      (setq org-latex-classes nil)))
#+end_src

***** LSP support in ~src~ blocks
Now, by default, LSPs don't really function at all in ~src~ blocks.
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src

**** Super agenda
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands (org-super-agenda-mode))
(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
#+end_src

**** Capture
Let's setup some org-capture templates, and make them visually nice to access.

#+begin_src emacs-lisp :noweb no-export
(use-package! doct
  :commands (doct))

(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defvar +org-capture-recipies  "~/Desktop/TEC/Organisation/recipies.org")

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a")
                   )
                  ("Personal note" :keys "n"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web"
                               )
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch"
                               )
                              ("\tRecipie" :keys "r"
                               :icon ("spoon" :set "faicon" :color "dorange")
                               :file +org-capture-recipies
                               :headline "Unsorted"
                               :template "%(org-chef-get-recipe-from-url)"
                               )
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info"
                               )
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea"
                               )))
                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra ""
                               )
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t"
                               )
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t"
                               )
                              ))
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file))
                   )
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file))
                   )))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src
It would also be nice to improve how the capture dialogue looks
#+name: prettify-capture
#+begin_src emacs-lisp :tangle no
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"â€¦

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "â€º" 'face 'font-lock-comment-face) "  " desc "â€¦" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src
The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.
#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "â– Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

** Python
Our nice docstring formatting tools
#+begin_src emacs-lisp
(use-package! python-docstring-mode :hook python-mode)
#+end_src

** Markdown
Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

Since markdown is often seen as rendered HTML, let's try to somewhat mirror the
style or markdown renderers.

Most markdown renders seem to make the first three headings levels larger than
normal text, the first two much so. Then the fourth level tends to be the same
as body text, while the fifth and sixth are (increasingly) smaller, with the
sixth greyed out. Since the sixth level is so small, I'll turn up the boldness a notch.
#+begin_src emacs-lisp
(custom-set-faces!
  '(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
  '(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src

** Writing
Some of the tools I use for academic writing.
*** Citations
Occasionally I want to cite something.
#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :config
  (require 'doi-utils)
  (setq org-ref-bibliography-notes "~/org/ref/notes.org"
        ;; org-ref-default-bibliography '("~/org/ref/references.bib")
        org-ref-default-bibliography (nconc '("~/org/ref/references.bib") (file-expand-wildcards "~/Documents/data-rapport/bibliographies/*.bib"))
        org-ref-pdf-directory "~/org/ref/bibtex-pdf/"
        biblio-download-directory "~/org/ref/bibtex-pdf/"
        bibtex-completion-pdf-open-function 'org-open-file
        org-ref-completion-library 'org-ref-ivy-cite
        doi-utils-open-pdf-after-download t)

;; Sci-hub
(defun sci-hub-pdf-url (doi)
  "Get url to the pdf from SCI-HUB"
  (setq *doi-utils-pdf-url* (concat "https://sci-hub.se/" doi)
        ,*doi-utils-waiting* t)
  ;; try to find PDF url (if it exists)
  (url-retrieve (concat "https://sci-hub.se/" doi)
            (lambda (status)
              (goto-char (point-min))
              (while (search-forward-regexp "\\(https://\\|//sci-hub.se/downloads\\).+download=true'" nil t)
                (let ((foundurl (match-string 0)))
                  (message foundurl)
                  (if (string-match "https:" foundurl)
                  (setq *doi-utils-pdf-url* foundurl)
                (setq *doi-utils-pdf-url* (concat "https:" foundurl))))
                (setq *doi-utils-waiting* nil))))
  (while *doi-utils-waiting* (sleep-for 0.1))
   ,*doi-utils-pdf-url*)

(defadvice! luklun/doi-utils-get-bibtex-entry-pdf (&optional arg)
    :override #'doi-utils-get-bibtex-entry-pdf
    (interactive "P")
    (save-excursion
      (bibtex-beginning-of-entry)
      (let ( ;; get doi, removing http://dx.doi.org/ if it is there.
        (doi (replace-regexp-in-string
          "https?://\\(dx.\\)?.doi.org/" ""
          (bibtex-autokey-get-field "doi")))
        (key (cdr (assoc "=key=" (bibtex-parse-entry))))
        (pdf-url)
        (pdf-file))
    (setq pdf-file (concat
            (if org-ref-pdf-directory
                (file-name-as-directory org-ref-pdf-directory)
              (read-directory-name "PDF directory: " "."))
            key ".pdf"))
    ;; now get file if needed.
    (unless (file-exists-p pdf-file)
      (cond
       ((and (not arg)
         doi
         (if (doi-utils-get-pdf-url doi)
             (setq pdf-url (doi-utils-get-pdf-url doi))
           (setq pdf-url "https://www.sciencedirect.com/science/article/")))
        (url-copy-file pdf-url pdf-file)
        ;; now check if we got a pdf
        (if (org-ref-pdf-p pdf-file)
        (message "%s saved" pdf-file)
          (delete-file pdf-file)
          ;; sci-hub fallback option
          (setq pdf-url (sci-hub-pdf-url doi))
          (url-copy-file pdf-url pdf-file)
          ;; now check if we got a pdf
          (if (org-ref-pdf-p pdf-file)
          (message "%s saved" pdf-file)
        (delete-file pdf-file)
        (message "No pdf was downloaded.") ; SH captcha
        (browse-url pdf-url))))
       ;; End of sci-hub fallback option
       ((equal arg '(4))
        (copy-file (expand-file-name (read-file-name "Pdf file: " nil nil t))
               pdf-file))
       ((equal arg '(16))
        (with-current-buffer (read-buffer-to-switch "Pdf buffer: ")
          (write-file pdf-file)))
       (t
        (message "We don't have a recipe for this journal.")))
      (when (and doi-utils-open-pdf-after-download (file-exists-p pdf-file))
        (org-open-file pdf-file)))))))
#+end_src

I find =helm-bibtex= perfect for displaying citation information and it also
integrates well with org-roam via org-roam-bibtex.
#+begin_src emacs-lisp
(use-package! helm-bibtex
  :after org
  :config
  (setq
   ;; bibtex-completion-bibliography '("~/org/ref/references.bib")
   bibtex-completion-bibliography (nconc '("~/org/ref/references.bib")
                                         (file-expand-wildcards "~/Documents/data-rapport/bibliographies/*.bib"))
   ))
#+end_src

The default method of opening pdfs in helm-bibtex is pretty lack-luster
(it will try to find pdf-key in the bibtex-entry or search online for the DOI,
which rarely works.) Org-ref, by default, names pdfs according to their bibtex cite-key
so we might as well leverage that functionality when opening pdfs.

#+begin_src emacs-lisp
(defadvice! luklun/bibtex-completion-find-pdf (key &optional fallback)
  :override #'bibtex-completion-find-pdf
  (list (org-ref-get-pdf-filename key)))

(defadvice! luklun/bibtex-completion-open-any (keys)
  :override #'bibtex-completion-open-any
  (bibtex-completion-open-pdf keys 'bibtex-completion-open-pdf))
#+end_src

Org-roam-bibtex allows us to add org-notes to bibtex entries.
Combined with our pdf management this gives us a wholistic way of managing
citations, notes, and pdf-management.

#+begin_src emacs-lisp
;; (use-package! org-roam-bibtex
;;   :after org-roam
;;   :config
;;   (setq orb-preformat-keywords '("citekey" "author" "date"))
;;   (setq org-roam-capture-templates
;;         '(("r" "bibliography reference" plain
;;            "%?
;; %^{author} published %^{entry-type} in %^{date}: fullcite:%\\1."
;;            :if-new
;;            (file+head "references/${citekey}.org" "#+title: ${title}\n")
;;            :unnarrowed t))))
#+end_src

*** Biblio

=biblio.el= provides a some useful ways to look up and copy citations.

First, we need to add some keybindings for the lookup tools
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "references")
       :desc "helm-bibtex" "d" #'helm-bibtex
       :desc "dblp-lookup" "l" #'dblp-lookup
       :desc "ieee-lookup" "i" #'ieee-lookup
       :desc "arxiv-lookup" "a" #'arxiv-lookup
       :desc "open bibtex" "b" #'(lambda () (interactive) (find-file (car org-ref-default-bibliography)))))
#+end_src

We can add some useful keybindings for bibtex mode also.
#+begin_src emacs-lisp
(map! :map bibtex-mode-map
      :ne "C-j" #'bibtex-next-entry
      :ne "C-k" #'bibtex-previous-entry
      :localleader
      :desc "Format entry" "f" #'org-ref-clean-bibtex-entry)
#+end_src

It is pretty nice to save the bibtex entries we copy from a biblio-search directly to our default bib-file.
#+begin_src emacs-lisp
(defadvice! luklun/save-bibtex-to-default (&rest _)
  ""
  :after #'biblio--selection-copy-callback
  (let ((bibliography (car org-ref-default-bibliography)))
    (save-excursion
      (with-temp-buffer
        (yank)
        (org-ref-clean-bibtex-entry)
        (let ((key (cdr (assoc "=key=" (bibtex-parse-entry)))))
          (if (not (org-ref-key-in-file-p key bibliography))
              (progn
                (append-to-file "\n" nil bibliography)
                (append-to-file nil nil bibliography)
                     (message (format "%s written to %s" key bibliography)))
            (message (format "%s already exist in %s" key bibliography))))))))
#+end_src

#+begin_src emacs-lisp
(defun luklun/download-arxiv-under-cursor ()
     (interactive)
     (let* ((entry (bibtex-parse-entry))
            (key (cdr (assoc "&key" entry)))
            (target-dir org-ref-pdf-directory)
            (target-file (concat target-dir key ".pdf"))
            (arxiv-num (cdr (assoc "eprint" entry))))
       (message "Parsed this entry %s" entry)
       (message "Arxiv Entry %s" key)
       (when (and (not (file-exists-p target-file)) arxiv-num)
         (arxiv-get-pdf arxiv-num target-path))))
#+end_src

Finally, add some nice vim-like bindings.
#+begin_src emacs-lisp
(use-package! biblio
  :bind
  (:map biblio-selection-mode-map
   ("j" . biblio--selection-next)
   ("k" . biblio--selection-previous)))
#+end_src

*** Tools
Some tools for extracting equations from pdfs
#+begin_src emacs-lisp :tangle packages.el
(package! mathpix
  :recipe (:host github :repo "jethrokuan/mathpix.el"))
#+end_src

#+begin_src emacs-lisp
(use-package! mathpix
  :defer t
  :bind ("C-x m" . mathpix-screenshot))

(after! mathpix

  (defun luklun/epa-decrypt-file (decrypt-file)
    "Decrypt DECRYPT-FILE and return as a string."
    (setq decrypt-file (expand-file-name decrypt-file))
    (let ((context (epg-make-context epa-protocol)))
      (epg-context-set-passphrase-callback context
					   #'epa-passphrase-callback-function)
      (epg-context-set-progress-callback context
				         (cons
					  #'epa-progress-callback-function
					  (format "Decrypting %s..."
						  (file-name-nondirectory decrypt-file))))
      (message "Decrypting %s..." (file-name-nondirectory decrypt-file))
      (condition-case error
	  (epg-decrypt-file context decrypt-file nil)
        (error
         (epa-display-error context)
         (signal (car error) (cdr error))))))


  (defun luklun/parse-encrypted-json (file)
    "Decrypt and parse the contents of encrypted json file"
    (json-read-from-string (luklun/epa-decrypt-file file)))


  (defadvice! luklun/mathpix-screenshot ()
    :override #'mathpix-screenshot
    "Capture screenshot and send result to Mathpix API."
    (interactive)
    (let ((default-directory "~"))
      (make-directory (file-name-directory mathpix-screenshot-file) t)
      (if (functionp mathpix-screenshot-method)
          (funcall mathpix-screenshot-method mathpix-screenshot-file)
        (shell-command-to-string
         (format mathpix-screenshot-method mathpix-screenshot-file)))
      (when (file-exists-p mathpix-screenshot-file)
        (kill-new (mathpix-get-result mathpix-screenshot-file))
        (delete-file mathpix-screenshot-file))))
  ;; This overrides the original defintion to send to kill-ring instead

  (setq
   +mathpix-key-file (concat doom-private-dir "secrets/mathpix-keys.json.gpg")
   mathpix-app-id (assoc-default 'mathpix-app-id (luklun/parse-encrypted-json +mathpix-key-file))
   mathpix-app-key (assoc-default 'mathpix-app-key (luklun/parse-encrypted-json +mathpix-key-file))))
#+end_src


Tools for extracting pdffigures from pdfs
#+begin_src emacs-lisp :tangle packages.el
(package! pdffigure
  :recipe (:local-repo "~/.config/doom/misc/pdffigures/"))
#+end_src

#+begin_src emacs-lisp
(use-package! pdffigures
  :config
  (setq
   pdffigures-jar-path "/home/luklun/repos/pdffigures2/target/scala-2.12/pdffigures2-assembly-0.1.0.jar"
   pdffigures-output-dir "~/org/roam/img"
   pdffigures-kill-saved-images t)
  (map! :map pdf-view-mode-map
        :localleader
        :desc "Crop pdf-figures" "c" #'pdffigures-crop))
#+end_src

** EWW
The web is bloated beyond any rhyme or reason, I just want text god darn it.

Protesilaos, aka. Prot built some nice extensions to the eww browser (wowser?).
We can download his dotfile and extract the things we find relevant

#+begin_src emacs-lisp :tangle packages.el
(package! prot-common
  :pin "2b983fcb9a8fd803792ca0bb20c49ec0763fb1bb"
  :recipe (:host gitlab :repo "protesilaos/dotfiles"
           :files ("emacs/.emacs.d/prot-lisp/prot-common.el")))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! prot-pulse
  :pin "2b983fcb9a8fd803792ca0bb20c49ec0763fb1bb"
  :recipe (
           :host gitlab :repo "protesilaos/dotfiles"
           :files ("emacs/.emacs.d/prot-lisp/prot-pulse.el")))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! prot-eww
  :pin "2b983fcb9a8fd803792ca0bb20c49ec0763fb1bb"
  :recipe (
           :host gitlab :repo "protesilaos/dotfiles"
           :files ("emacs/.emacs.d/prot-lisp/prot-eww.el")))
#+end_src

*** SHR
=shr= is the underlying html rendering engine used by =eww=
#+begin_src emacs-lisp
(use-package! shr
  :config (setq shr-user-colors nil
                shr-max-image-proportion 0.6
                shr-image-animate nil
                shr-width nil
                shr-discard-aria-hidden t
                shr-cookie-policy nil))

#+end_src

*** Browse Url
Set the default functions for opening a link in Emacs.
In the case that we want (or are forced) to handle some bloatware site we can
then propogate it to the system default browser.

#+begin_src emacs-lisp
(use-package! browse-url
  :config
  (setq browse-url-browser-function 'eww-browse-url
        browse-url-secondary-browser-function 'browse-url-default-browser))
#+end_src

*** Emacs Web Wowser
We start by setting some nice defaults
#+begin_src emacs-lisp
(use-package! eww
  :config
  ;; Lets enable zen-mode by default in eww for a nice reading experience
  (add-hook 'eww-after-render-hook #'+zen/toggle)
  (setq
   eww-restore-desktop t
   eww-desktop-remove-duplicates t
   eww-header-line-format nil
   ;; eww-search-prefix "https://duckduckgo.com/html/?q="
   eww-search-prefix "https://www.startpage.com/do/dsearch?query="
   eww-download-directory (expand-file-name "~/Downloads/eww")
   eww-suggest-uris '(eww-links-at-point thing-at-point-url-at-point)
   eww-bookmarks-director (thread-last doom-private-dir (expand-file-name "eww-bookmarks/"))
   eww-history-limit 1000
   eww-use-external-browser-for-content-type "\\`\\(video/\\|audio\\)" ; On GNU/Linux check your mimeapps.list
   eww-browse-url-new-window-is-tab nil
   eww-form-checkbox-selected-symbol "[X]"
   eww-form-checkbox-symbol "[ ]")
  ;; Add some evil keybindings for common operations
  (map! :map eww-mode-map
        :localleader
        :desc "Copy url" "y" #'eww-copy-page-url
        :desc "Jump to url" "j" #'prot-eww-jump-to-url-on-page
        :desc "Goto url" "g" #'prot-eww-visit-url-on-page
        :desc "Open in another window" "w" #'prot-eww-open-in-other-window
        :desc "Bookmark page" "b" #'prot-eww-bookmark-page
        :desc "Open bookmark" "B" #'prot-eww-visit-bookmark))

;; Some ways to quickly launch EWW is also practical
(map! :leader
        (:prefix ("e" . "eww")
         :desc "Launch" "e" #'eww
         :desc "Launch with completion" "d" #'prot-eww-browse-dwim
         :desc "Search words at point" "w" #'eww-search-words
         :desc "List bookmarks" "b" #'eww-list-bookmarks
         :desc "List history" "h" #'eww-list-histories))
#+end_src

Finally we load Prot's eww extentions
#+begin_src emacs-lisp
(use-package! prot-eww)
#+end_src

*** Org-Web-Tools
Who doesn't want to browse the web in org-mode.
#+begin_src emacs-lisp :tangle packages.el
(package! org-web-tools
  :pin "b94a07add8558ef7b0666173dbb8a2554f1d41a6")
#+end_src

#+begin_src emacs-lisp
(use-package! org-web-tools)
#+end_src

* Finishing Touches
** Managing Popups in Doom
Doom has its own system for managing popups.
Certain buffers are opened in the popup-buffer and discarded when the window is closed.

By default doom emacs launches EWW in a popup-buffer.
This is a bit annoying if we want to use EWW as a real browser (wowser?).
This can be fixed by adding an ignore rule in the list of popup-rules.

#+begin_src emacs-lisp
(set-popup-rule! "^\\*\\([Hh]elp\\|Apropos\\)" :ignore t)
(set-popup-rule! ".*eww\\*.*" :ignore t)
(set-popup-rule! ".*eww\\*.*" :ignore t)
(set-popup-rule! "^\\*arXiv.*" :ignore t )
(set-popup-rule! "^*DBLP" :ignore t)
#+end_src

** EIN
Jupyter Notebooks are perfect for doing experimental work.
However, having to use the browser for coding is a scurge.

#+begin_src emacs-lisp
(map! :leader
      :desc "Open eshell" "o s" #'eshell)
#+end_src

** EWW
The web is bloated beyond any rhyme or reason, I just want text god darn it.

Protesilaos, aka. Prot built some nice extensions to the eww browser (wowser?).
We can download his dotfile and extract the things we find relevant

#+begin_src emacs-lisp :tangle packages.el
(package! prot-common
  :pin "2b983fcb9a8fd803792ca0bb20c49ec0763fb1bb"
  :recipe (:host gitlab :repo "protesilaos/dotfiles"
           :files ("emacs/.emacs.d/prot-lisp/prot-common.el")))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! prot-pulse
  :pin "2b983fcb9a8fd803792ca0bb20c49ec0763fb1bb"
  :recipe (
           :host gitlab :repo "protesilaos/dotfiles"
           :files ("emacs/.emacs.d/prot-lisp/prot-pulse.el")))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! prot-eww
  :pin "2b983fcb9a8fd803792ca0bb20c49ec0763fb1bb"
  :recipe (
           :host gitlab :repo "protesilaos/dotfiles"
           :files ("emacs/.emacs.d/prot-lisp/prot-eww.el")))
#+end_src

*** SHR
=shr= is the underlying html rendering engine used by =eww=
#+begin_src emacs-lisp
(use-package! shr
  :config (setq shr-user-colors nil
                shr-max-image-proportion 0.6
                shr-image-animate nil
                shr-width nil
                shr-discard-aria-hidden t
                shr-cookie-policy nil))

#+end_src

*** Browse Url
Set the default functions for opening a link in Emacs.
In the case that we want (or are forced) to handle some bloatware site we can
then propagate it to the system default browser.

#+begin_src emacs-lisp
(use-package! browse-url
  :config
  (setq browse-url-browser-function 'eww-browse-url
        browse-url-secondary-browser-function 'browse-url-default-browser))
#+end_src

*** Emacs Web Wowser
We start by setting some nice defaults
#+begin_src emacs-lisp
(use-package! eww
  :config
  ;; Lets enable zen-mode by default in eww for a nice reading experience
  (add-hook 'eww-after-render-hook #'+zen/toggle)
  (setq
   eww-restore-desktop t
   eww-desktop-remove-duplicates t
   eww-header-line-format nil
   ;; eww-search-prefix "https://duckduckgo.com/html/?q="
   eww-search-prefix "https://www.startpage.com/do/dsearch?query="
   eww-download-directory (expand-file-name "~/Downloads/eww")
   eww-suggest-uris '(eww-links-at-point thing-at-point-url-at-point)
   eww-bookmarks-director (thread-last doom-private-dir (expand-file-name "eww-bookmarks/"))
   eww-history-limit 1000
   eww-use-external-browser-for-content-type "\\`\\(video/\\|audio\\)" ; On GNU/Linux check your mimeapps.list
   eww-browse-url-new-window-is-tab nil
   eww-form-checkbox-selected-symbol "[X]"
   eww-form-checkbox-symbol "[ ]")
  ;; Add some evil keybindings for common operations
  (map! :map eww-mode-map
        :localleader
        :desc "Copy url" "y" #'eww-copy-page-url
        :desc "Jump to url" "j" #'prot-eww-jump-to-url-on-page
        :desc "Goto url" "g" #'prot-eww-visit-url-on-page
        :desc "Open in another window" "w" #'prot-eww-open-in-other-window
        :desc "Bookmark page" "b" #'prot-eww-bookmark-page
        :desc "Open bookmark" "B" #'prot-eww-visit-bookmark))

;; Some ways to quickly launch EWW is also practical
(map! :leader
        (:prefix ("e" . "eww")
         :desc "Launch" "e" #'eww
         :desc "Launch with completion" "d" #'prot-eww-browse-dwim
         :desc "Search words at point" "w" #'eww-search-words
         :desc "List bookmarks" "b" #'eww-list-bookmarks
         :desc "List history" "h" #'eww-list-histories))
#+end_src

Finally we load Prot's eww extentions
#+begin_src emacs-lisp
(use-package! prot-eww)
#+end_src

*** Org-Web-Tools
Who doesn't want to browse the web in org-mode.
#+begin_src emacs-lisp :tangle packages.el
(package! org-web-tools
  :pin "b94a07add8558ef7b0666173dbb8a2554f1d41a6")
#+end_src

#+begin_src emacs-lisp
(use-package! org-web-tools)
#+end_src

#+begin_src emacs-lisp :tangle yes
(which-key-mode)
#+end_src

** Smaller quality of life changes

When working with more complex Vue components it is nice to split
them into multiple files. Adding these extensions makes it easy to quickly
switch between different files.

#+begin_src emacs-lisp
(after! projectile
  (push '("vue" "css" "ts" "js") projectile-other-file-alist)
  (push '("css" "ts" "js" "vue") projectile-other-file-alist)
  (push '("ts" "vue" "css") projectile-other-file-alist)
  (push '("js" "vue" "css") projectile-other-file-alist))
#+end_src

Adding keybinding for formatting buffers
#+begin_src emacs-lisp
(map! :leader
      :desc "Format buffer"
      "b f" '+format/buffer)
#+end_src
